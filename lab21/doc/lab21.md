# Лабораторна робота №21. ООП. Шаблонні функції та класи

## 1 Вимоги

### 1.1 Розробник

* Рекало Іван Сергійович;
* студент групи КН923г;
* 15-вер-2024.

### 1.2 Завдання

1. Зробити шаблоний клас-список (на базі динамічного масиву), що має шаблоноване поле масиву (для будь-якого існуючого типу даних)
2. Створити наступні методи:
- вивод вмісту масиву на екран;
- визначити індекс переданого елемента в заданому масиві;
- відсортувати елементи масиву;
- визначити значення мінімального елемента масиву;
- додати елемент до кінця масиву;
- видалити елемент з масиву за індексом.

## 2 Опис програми

### 2.1 Функціональне призначення

Програма призначена для управління масивом елементів, що може містити різні типи даних. Вона дозволяє додавати нові елементи, видаляти існуючі, отримувати інформацію про елементи за індексом, знаходити мінімальний елемент у масиві, а також здійснювати сортування елементів у списку.

### 2.2 Опис логічної структури

#### Клас List
```C
template<typename T>
class List {
```

*Призначення*: управляє списком елементів у масиві.

*Методи*: 

- Конструктор
- Деструктор
- display(): виводить всі елементи масиву на екран.
- indexOf(const T& element): визначає індекс елемента.
- sortarray(): сортує елементи масиву.
- min(): визначає значення мінімального елементу у масиві.
- add(const T& element): додає елемент у кінець масиву.
- remove(size_t index): видаляє елемент за індексом.
- T& operator[](size_t index): оператор доступу за індексом.
- friend ostream& operator<<(ostream& os, const List& list): оператор виведення.
- friend istream& operator>>(istream& is, List& list): оператор введення.
- getSize(): отримання розміру для тестування програми.

#### Головна функція
```C
int main();
```

*Призначення*: головна функція main є точкою входу в програму, де здійснюється ініціалізація даних і управління масивом елементів.

*Опис роботи*:

- Створення масиву: ініціалізується об'єкт **List<int>**, який буде використовуватися для зберігання цілих чисел.
- Додавання елементів до масиву: додаються різні числа до списку.
- Виведення всіх елементів: виводяться на екран всі елементи масиву.
- Сортування елементів: використовується метод **sortarray** для сортування елементів.
- Отримання індексу елемента: визначається індекс елемента 256.
- Визначення мінімального елемента: повертається і виводиться мінімальний елемент масиву.
- Видалення елемента: видаляється елемент за індексом 4, і оновлений масив виводиться на екран.

#### Структура проекту
```
                 └── lab21
                     ├── Makefile
                     ├── Doxyfile
                     ├── README.md
                     ├── doc
                         └── lab21.md
                     ├── src
                         ├── list.hpp
                         ├── main.cpp
                     └── test
                         └── test.cpp
```

### 2.3 Важливі фрагменти програми

#### Конструктор
```C
List() : array(nullptr), size(0), capacity(0) {}
```

#### Вивод масиву на екран
```C
    void display() const {
        for (size_t i = 0; i < size; ++i) {
            cout << array[i] << " ";
        }
        cout << endl;
    }
```

#### Сортування масиву
```C
    void sortarray() {
        sort(array, array + size);
    }
```

#### Визначення індексу елемента масиву
```C
 	size_t indexOf(const T& element) const {
    	for (size_t i = 0; i < size; ++i) {
        	if (array[i] == element) {
            	return i;
        	}
    	}
    return static_cast<size_t>(-1);
 	}
```

#### Визначення значення мінімального елемента масиву
```C
    T min() const {
        if (size == 0) {
            throw out_of_range("Масив порожній");
        }
        return *min_element(array, array + size);
    }

    // Додавання елемента у кінець масиву
    void add(const T& element) {
        if (size == capacity) {
            resize();
        }
        array[size++] = element;
    }
```

#### Додавання елемента у кінець масиву
```C
    void add(const T& element) {
        if (size == capacity) {
            resize();
        }
        array[size++] = element;
    }

```

#### Видалення елемента за індексом
```C
    void remove(size_t index) {
        if (index >= size) {
            throw out_of_range("Індекс поза межами");
        }
        for (size_t i = index; i < size - 1; ++i) {
            array[i] = array[i + 1];
        }
        --size;
    }
```

#### Перевірка відсутності витоків пам'яті за допомогою утиліти valgrind
```C
==19690== Memcheck, a memory error detector
==19690== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==19690== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==19690== Command: ./main
==19690== 
Список: 17 2 28 3 9 25 256 1024 
Список після сортування: 2 3 9 17 25 28 256 1024 
Індекс елемента 256: 6
Мінімальний елемент: 2
Список після видалення елемента за індексом 4: 2 3 9 17 28 256 1024 
==19690== 
==19690== HEAP SUMMARY:
==19690==     in use at exit: 0 bytes in 0 blocks
==19690==   total heap usage: 6 allocs, 6 frees, 73,788 bytes allocated
==19690== 
==19690== All heap blocks were freed -- no leaks are possible
==19690== 
==19690== For lists of detected and suppressed errors, rerun with: -s
==19690== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

#### Модульний тест
```C
./dist/test.bin
Список: 10 18 371 3 
Список після сортування: 3 10 18 371
Список після видалення елемента за індексом 2: 3 10 371
Нове виведення списку: 3 10 371
Всі тести пройдено!
```

## 3 Варіанти використання

#### Програма може бути використана для:

1. Демонстрації принципів ООП у навчальних цілях.
2. Розробки програмного забезпечення для управління масивами.
3. Сортування та пошуку даних у масивах.

## Висновки

Лабораторній робота навчила нас розробляти шаблонні функції для взаємодії з різними типами даних, а також познайомила нас з різними методами роботи з масивами: вивод вмісту на екран, додавання та видалення елементів, сортування масиву та визначення індексів елементів